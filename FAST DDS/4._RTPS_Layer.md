# 4.RTPS Layer
eprosima Fast DDS的底层RTPS层服务于RTPS标准中定义的协议的实现。与DDS层相比，该层提供了对通信协议内部的更多控制，因此高级用户可以更好地控制库的功能。
## 4.1. 与DDS层的关系
该层的元素与DDS层的元素进行一对一的映射，并进行一些添加。这种对应关系见下表:
| DDS Layer | RTPS Layer |
|--------|--------|
| Domain | RTPSDomain |
| DomainParticipant | RTPSParticipant |
| DataWriter | RTPSWriter |
| DataReader | RTPSReader |
## 4.2. 如何使用RTPS层
现在我们将像使用DDS Layer 1一样使用RTPS Layer，解释它所呈现的新特性。我们建议您在阅读本节时查看描述如何使用发行版附带的RTPS层的两个示例。它们分别位于examples/cpp/rtps/AsSocket和examples/cpp/rtps/Registered中。
### 4.2.1. 管理participant
通过RTPSDomain::createParticipant()创建rtpparticipant。RTPSParticipantAttributes结构用于在创建时配置rtpspparticipant。
```cpp
    RTPSParticipantAttributes participant_attr;
    participant_attr.setName("participant");
    RTPSParticipant* participant = RTPSDomain::createParticipant(0, participant_attr);
```
### 4.2.2. 管理写入器和读取器
正如RTPS标准所指定的，RTPSWriters和RTPSReaders总是与一个History元素相关联。在DDS层中，它的创建和管理是隐藏的，但在RTPS层中，您可以完全控制它的创建和配置。
使用RTPSDomain::createRTPSWriter()创建writers，并配置WriterAttributes结构。它们还需要一个WriterHistory，该WriterHistory使用HistoryAttributes结构进行配置。
```cpp
HistoryAttributes history_attr;
WriterHistory* history = new WriterHistory(history_attr);
WriterAttributes writer_attr;
RTPSWriter* writer = RTPSDomain::createRTPSWriter(participant, writer_attr, history);
```
与创建writer类似，使用RTPSDomain::createRTPSReader()创建reader，并配置ReaderAttributes结构。HistoryAttributes结构用于配置所需的ReaderHistory。注意，在这种情况下，你可以提供ReaderListener类的专门化来实现你的回调函数：
```cpp
class MyReaderListener : public ReaderListener
{
    // Callbacks override
};
MyReaderListener listener;
HistoryAttributes history_attr;
ReaderHistory* history = new ReaderHistory(history_attr);
ReaderAttributes reader_attr;
RTPSReader* reader = RTPSDomain::createRTPSReader(participant, reader_attr, history, &listener);
```
### 4.2.3. 使用history发送和接收数据
在RTPS协议中，reader和writer将一个主题的数据保存在它们相关联的历史记录中。每个数据块都由一个Change表示，eprosima Fast DDS将其实现为CacheChange_t。更改总是由历史记录管理。
你可以在Writer的History中添加一个新的CacheChange_t来发送数据。操作步骤如下:
1. 使用RTPSWriter::new_change()从Writer请求一个CacheChange_t。为了分配足够的内存，您需要提供一个回调函数，该回调函数返回有效负载中的最大字节数。
2. 用数据填充CacheChange_t。
3. 使用WriterHistory::add_change()将其添加到历史记录中。
writer将负责将数据传达给reader。
```cpp
//Request a change from the writer
CacheChange_t* change = writer->new_change([]() -> uint32_t
                {
                    return 255;
                }, ALIVE);
//Write serialized data into the change
change->serializedPayload.length = sprintf((char*) change->serializedPayload.data, "My example string %d", 2) + 1;
//Insert change into the history. The Writer takes care of the rest.
history->add_change(change);
```
如果您的topic数据类型有几个字段，则必须提供在CacheChange_t内外序列化和反序列化数据的函数。Fast DDS-Gen为您做到了这一点。
你可以从ReaderListener::onNewCacheChangeAdded回调中接收数据，就像我们在DDS层中做的那样:
1. 回调接收一个CacheChange_t参数，其中包含接收到的数据。
2. 处理接收到的CacheChange_t中的数据。
3. 通知Reader 's History不再需要更改。
```cpp
class MyReaderListener : public ReaderListener
{
public:

    MyReaderListener()
    {
    }

    ~MyReaderListener()
    {
    }

    void onNewCacheChangeAdded(
            RTPSReader* reader,
            const CacheChange_t* const change)
    {
        // The incoming message is enclosed within the `change` in the function parameters
        printf("%s\n", change->serializedPayload.data);
        // Once done, remove the change
        reader->getHistory()->remove_change((CacheChange_t*)change);
    }

};
```
### 4.2.4. 管理内置传输
DDS使用传输层来允许DDS实体之间的通信。eProsima Fast DDS已经实现了五种传输。然而，这些传输在它们之间并不总是排他性的，在某些情况下它们可以同时使用。
您可以通过禁用内置传输的使用并手动添加它们（参见TransportConfigQos），或使用默认的内置传输行为并选择下面列出的配置选项之一，来选择您希望使用的传输方式。每个选项都会修改将要实例化的传输类型。
| Builtin Transports Options | Description |
|--------|--------|
| NONE | 不会实例化任何传输。因此，用户必须手动添加所需的传输。否则，participant创建将失败。 |
|DEFAULT|UDPv4和SHM传输将被实例化。SHM传输的传输优先级高于udv4。这意味着在可能的情况下总是使用SHM进行传输。|
|DEFAULTv6|UDPv6和SHM传输将被实例化。SHM传输的传输优先级高于udv4。这意味着在可能的情况下总是使用SHM。|
| SHM | 只有SHM传输将被实例化。 |
| UDPv4 | 只有UDPv4传输将被实例化。 |
| UDPv6 | 只有UDPv6传输将被实例化。 |
| LARGE_DATA | 然而，UDP将只被使用有关participant发现阶段的多播通知(请参阅发现阶段)，而participant的活跃度（liveliness）和应用程序的数据传递是通过TCP或SHM进行的。 |
```cpp
RTPSParticipantAttributes participant_attr;
participant_attr.setup_transports(eprosima::fastdds::rtps::BuiltinTransports::LARGE_DATA);
RTPSParticipant* participant = RTPSDomain::createParticipant(0, participant_attr);
```
使用DomainParticipantQos的setup_transports()包装器函数、XML配置文件(参见RTPS元素类型)或FASTDDS_BUILTIN_TRANSPORTS环境变量(参见FASTDDS_BUILTIN_TRANSPORTS)也可以获得相同的结果。
TCPv4传输用以下配置初始化:
1. Calculate_crc, check_crc和apply_security设置为false。 
2. Enable_tcp_nodelay设置为true。 
3. Keep_alive_thread和accept_thread使用默认配置。
**注意**
为了在处理大型数据消息时获得更好的性能，强烈建议使用内置的传输配置选项来调整传输以满足应用程序的特定需求。有关如何配置它的更多信息，请参阅带有配置选项的大数据。
## 4.3 配置读写器
使用RTPS层的好处之一是，它提供了新的配置可能性，同时保留了DDS层的选项。例如，您可以像前面一样将Writer或Reader设置为Reliable或Best-Effort端点:
```cpp
writer_attr.endpoint.reliabilityKind = BEST_EFFORT;

```
### 4.3.1. 设置数据持久性类型
Durability参数定义了当一个新的Reader匹配时，Writer对于已经发送的样本的行为。eProsima Fast DDS提供三种Durability选项:
- VOLATILE(默认值): 消息在发送时被丢弃。如果第n条消息之后匹配到一个新的Reader，这个Reader将从消息n+1开始接收。 
- TRANSIENT_LOCAL: Writer保存它最近发送的k条消息的记录。如果在消息n之后匹配到一个新的Reader，它将开始从消息n-k接收。
- TRANSIENT: 与TRANSIENT_LOCAL一样，但是消息记录将被保存到持久存储中，因此，如果Writer被销毁并重新创建，或者在应用程序崩溃的情况下，它将可用。
选择您喜欢的选项:
```cpp
writer_attr.endpoint.durabilityKind = TRANSIENT_LOCAL;
```
因为在RTPS层，你可以控制History,在TRANSIENT_LOCAL和TRANSIENT模式下,Writer发送所有你没有从History中明确释放的更改。
## 4.4.配置History
History有它自己的配置结构，即HistoryAttributes。
### 4.4.1.更改有效负载的最大大小
您可以选择可以放入CacheChange_t的有效负载的最大大小。一定要选择一个能够容纳最大数据块的大小:
```cpp
history_attr.payloadMaxSize  = 250;//Defaults to 500 bytes
```
### 4.4.2.更改History的大小
您可以指定History的最大缓存和初始缓存:
```cpp
history_attr.initialReservedCaches = 250; //Defaults to 500
history_attr.maximumReservedCaches = 500; //Defaults to 0 = Unlimited Changes
```
当初始缓存小于最大缓存时，History将根据需要分配更多缓存，直到达到最大大小。
## 4.5.使用自定义负载池
Payload被定义为用户想要在Writer和Reader之间传输的数据。RTPS需要向Payload添加一些元数据，以便管理端点之间的通信。因此，这个Payload被封装在CacheChange_t的SerializedPayload_t字段中，而CacheChange_t的其余字段提供所需的元数据。
WriterHistory和ReaderHistory为用户提供了与这些更改交互的接口:由Writer传输的更改被添加到它的WriterHistory中，并且已经在Reader上处理的更改可以从ReaderHistory中删除。从这个意义上说，History充当了尚未完全处理的更改的缓冲区。
在正常执行过程中，新的更改被添加到History中，旧的更改被删除。为了管理这些更改中包含的有效负载的生命周期，reader和writer使用了一个pool对象，它是IPayloadPool接口的实现。不同的池实现允许不同的优化。例如，可以从不同的预分配内存块中检索不同大小的有效负载。
Writer和Reader自动选择最适合HistoryAttributes中给出的配置的默认负载池实现。但是，可以将自定义负载池提供给RTPSDomain::createRTPSWriter()和RTPSDomain::createRTPSReader()函数。当请求或释放新的CacheChange_t时，Writer和Reader将使用提供的pool。
### 4.5.1. IPayloadPool接口
- 使用size参数重载IPayloadPool::get_payload : 将请求大小的空负载绑定到CacheChange_t实例。然后可以用所需的数据填充有效负载。
- 使用SerializadPayload参数重载IPayloadPool : 将给定的Payload数据从池复制到一个新的Payload，并将其绑定到CacheChange_t实例。这个重载还接受一个指向拥有原始负载的池的指针。这允许进行某些优化，例如，如果原始负载来自同一池，则共享负载，从而避免复制操作。
- IPayloadPool::release_payload : 将绑定到CacheChange_t的Payload返回到池，并打破绑定。
**重要**
在实现自定义有效负载池时，请确保分配的有效负载满足标准RTPS序列化的要求。具体来说，有效负载必须足够大，以容纳序列化的用户数据加上RTPS标准第10.2节中指定的SerializedPayloadHeader的4个字节。
例如，如果我们知道序列化用户数据的上限，我们可以考虑实现一个池，它总是分配固定大小的有效负载，大到足以容纳任何这些数据。如果序列化的用户数据最多有N个字节，那么分配的有效负载必须至少有N+4个字节。
注意，请求IPayloadPool::get_payload的大小已经考虑了这个4字节的头。
### 4.5.2. 默认负载池实现
如果没有为Writer或Reader提供自定义负载池，Fast DDS将自动使用与History的memoryPolicy配置最匹配的默认实现。
**PREALLOCATED_MEMORY_MODE**
所有的有效负载将有一个固定大小的数据缓冲区，等于payloadMaxSize的值，不管向IPayloadPool::get_payload请求的大小。释放的有效负载可以被另一个CacheChange_t重用。这减少了内存分配操作，但代价是更高的内存使用。
在初始化History期间，initialReservedCaches会为初始分配的CacheChange_t预分配有效负载。
**PREALLOCATED_WITH_REALLOC_MEMORY_MODE**
有效负载保证具有至少与请求大小和payloadMaxSize之间的最大值一样大的数据缓冲区。释放的有效负载可以被另一个CacheChange_t重用。如果至少有一个空闲的有效负载，其缓冲区大小等于或大于请求的缓冲区大小，则不进行内存分配。
在初始化History期间，initialReservedCaches会为初始分配的CacheChange_t预分配有效负载。
**DYNAMIC_RESERVE_MEMORY_MODE**
每次请求Payload时，都会在内存中分配一个大小合适的新Payload。payloadMaxSize被忽略。释放的有效负载的内存总是被重新分配，因此池中永远不会有空闲的有效负载。这以频繁的内存分配为代价减少了内存使用。
在History的初始化中没有预先分配有效Payload
**DYNAMIC_REUSABLE_MEMORY_MODE**
保证有效负载具有至少与请求大小相同的数据缓冲区。payloadMaxSize被忽略。
释放的有效负载可以被另一个CacheChange_t重用。如果至少有一个空闲的有效负载，其缓冲区大小等于或大于请求的缓冲区大小，则不进行内存分配。
### 4.5.3. 使用实例自定义负载池
```cpp
// A simple payload pool that reserves and frees memory each time
class CustomPayloadPool : public IPayloadPool
{
    bool get_payload(
            uint32_t size,
            CacheChange_t& cache_change) override
    {
        // Reserve new memory for the payload buffer
        octet* payload = new octet[size];

        // Assign the payload buffer to the CacheChange and update sizes
        cache_change.serializedPayload.data = payload;
        cache_change.serializedPayload.length = size;
        cache_change.serializedPayload.max_size = size;

        // Tell the CacheChange who needs to release its payload
        cache_change.payload_owner(this);

        return true;
    }

    bool get_payload(
            SerializedPayload_t& data,
            IPayloadPool*& /*data_owner*/,
            CacheChange_t& cache_change)
    {
        // Reserve new memory for the payload buffer
        octet* payload = new octet[data.length];

        // Copy the data
        memcpy(payload, data.data, data.length);

        // Tell the CacheChange who needs to release its payload
        cache_change.payload_owner(this);

        // Assign the payload buffer to the CacheChange and update sizes
        cache_change.serializedPayload.data = payload;
        cache_change.serializedPayload.length = data.length;
        cache_change.serializedPayload.max_size = data.length;

        return true;
    }

    bool release_payload(
            CacheChange_t& cache_change) override
    {
        // Ensure precondition
        if (this != cache_change.payload_owner())
        {
            std::cerr << "Trying to release a payload buffer allocated by a different PayloadPool." << std::endl;
            return false;
        }

        // Dealloc the buffer of the payload
        delete[] cache_change.serializedPayload.data;

        // Reset sizes and pointers
        cache_change.serializedPayload.data = nullptr;
        cache_change.serializedPayload.length = 0;
        cache_change.serializedPayload.max_size = 0;

        // Reset the owner of the payload
        cache_change.payload_owner(nullptr);

        return true;
    }

};

std::shared_ptr<CustomPayloadPool> payload_pool = std::make_shared<CustomPayloadPool>();

// A writer using the custom payload pool
HistoryAttributes writer_history_attr;
WriterHistory* writer_history = new WriterHistory(writer_history_attr);
WriterAttributes writer_attr;
RTPSWriter* writer = RTPSDomain::createRTPSWriter(participant, writer_attr, payload_pool, writer_history);

// A reader using the same instance of the custom payload pool
HistoryAttributes reader_history_attr;
ReaderHistory* reader_history = new ReaderHistory(reader_history_attr);
ReaderAttributes reader_attr;
RTPSReader* reader = RTPSDomain::createRTPSReader(participant, reader_attr, payload_pool, reader_history);

// Write and Read operations work as usual, but take the Payloads from the pool.
// Requesting a change to the Writer will provide one with an empty Payload taken from the pool
CacheChange_t* change = writer->new_change([]() -> uint32_t
                {
                    return 255;
                }, ALIVE);

// Write serialized data into the change and add it to the history
change->serializedPayload.length = sprintf((char*) change->serializedPayload.data, "My example string %d", 2) + 1;
writer_history->add_change(change);
```
























